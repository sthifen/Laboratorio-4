[0418][ULI] Ensure RESTART condition is properly generated
[04c7][H3] ADT7420-Specific Protocol
[0841][ULI] Manages SCL clock generation
[0a13][H3] Implementation Steps
[0aea][P] This sensor is perfect for learning because it:
[12c3][ULI] Check:
[1411][ULI] Slave Address: 0x4B
[147e][ULI] Typical speeds: 100 kHz (Standard) or 400 kHz (Fast mode)
[14c2][ULI] Check I²C timing parameters
[1797][ULI] Confirm sensor is in correct operating mode
[1948][OLI] Add the XDC constraints file
[1d64][ULI] Resolution: 0.0625°C per LSB
[1e80][ULI] Requires minimal external components
[212c][P] 4. ACK Errors
[24b8][ULI] Converts temperature to BCD format
[2ba7][H3] Step 2: Synthesis and Implementation
[2bac][H3] Constraints File (XDC)
[2c25][OLI] Program the device with generated bitstream
[2dc6][ULI] Initializes ADT7420 sensor
[2edc][ULI] Verify SDA and SCL pin assignments in XDC
[2f0f][P] First, we need a robust I²C master controller:
[2f5a][H3] Debugging Tips
[3138][ULI] Converts raw data to temperature value
[31e3][P] Here’s the complete constraint file for the Nexys A7 board:
[3662][P] The temperature is stored as a 13-bit or 16-bit two’s complement value:
[37a5][P] Let’s build our temperature sensor interface step by step.
[3bf0][H3] Conclusion
[3c58][ULI] Check anode multiplexing timing
[3d9c][ULI] Includes interrupt capabilities for threshold detection
[40bf][P] Reading from Registers:
[4182][ULI] Manages read timing and sequencing
[446c][P] 3. Display Flickering
[448b][ULI] Lower 3 bits of LSB are don’t care
[4823][ULI] Half-duplex communication (not simultaneous send/receive)
[4a7a][P] The ADT7420 acts as an I²C slave device with address 0x4B. Key implementation details:
[4af3][ULI] Symptom: i2c_ack_error flag is high
[4bf1][ULI] Multi-master, multi-slave architecture
[4d60][P] Output interface:
[4ddc][H3] I²C Fundamentals
[4eff][ULI] Solutions:
[4f9f][PRE] create_debug_core u_ila_0 ila
set_property C_DATA_DEPTH 1024 [get_debug_cores u_ila_0]
connect_debug_port u_ila_0/clk [get_nets clk]
connect_debug_port u_ila_0/probe0 [get_nets sda]
connect_debug_port u_ila_0/probe1 [get_nets scl]
connect_debug_port u_ila_0/probe2 [get_nets state] Conclusion Building this temperature sensor interface has been an incredible journey from understanding I2C protocol specifications to seeing real-time temperature readings on hardware. The project demonstrates how FPGAs bridge the gap between low-level hardware communication and user-friendly displays.
[50b9][H3] Verilog Implementation
[532e][P] 1. No I²C Communication
[538f][ULI] Symptom: LEDs don’t change, display shows zeros
[58c4][H3] Why ADT7420?
[5b54][H3] Step 3: Programming the FPGA
[6091][P] Key characteristics:
[61a8][ULI] MSB contains sign bit and upper temperature bits
[6376][ULI] Verify BCD conversion logic
[65a9][H3] Using Vivado ILA for Debug
[68f2][P] Critical Point: The ADT7420 requires a RESTART condition between the write (register address) and read operations. Without it, the address register resets to 0x00, causing read failures.
[6c73][P] 13-bit mode (default):
[70ef][ULI] Operating Range: -40°C to +150°C
[720e][ULI] Displays temperature with decimal point
[723c][P] Our system consists of three main modules:
[72b4][OLI] Review synthesis warnings (address any critical warnings)
[7318][OLI] Open Hardware Manager in Vivado
[7752][ULI] Symptom: Temperature values are unrealistic
[7b54][ULI] Multiplexes seven-segment displays
[7b8b][OLI] Create a new Vivado project
[8563][H3] Design Architecture
[8592][ULI] Generates START/STOP/RESTART conditions
[87a8][ULI] Offers configurable temperature thresholds
[87f6][ULI] Reduce refresh rate if too fast
[884f][P] Before diving into implementation, let’s understand the I²C protocol a two-wire serial communication standard invented by Philips (now NXP).
[8c86][ULI] Verify slave address (0x4B for ADT7420)
[8d15][ULI] Resolution: Up to 16-bit precision
[8ef8][ULI] Detects acknowledgment bits
[93f2][ULI] Solutions:
[947b][ULI] SCL (Serial Clock): Clock signal generated by the master
[95fa][ULI] Symptom: Seven-segment displays flicker or show wrong digits
[9b68][ULI] Check MSB/LSB byte order
[9d82][ULI] Handles bidirectional SDA signaling
[9eda][H3] Understanding the Hardware: ADT7420 Temperature Sensor
[a041][ULI] Use ILA (Integrated Logic Analyzer) to observe I²C signals
[a0f4][IMG] ADT7420 Register Map
[a5e9][H3] Introduction
[a97a][ULI] Range: -40°C to +150°C
[ac4f][PRE] module i2c_master (
    input wire clk,           // System clock (100 MHz)
    input wire reset,
    input wire enable,        // Start transaction
    input wire rw,            // 1=Read, 0=Write
    input wire [6:0] addr,    // 7-bit slave address
    input wire [7:0] data_in, // Data to write
    output reg [7:0] data_out, // Data read
    output reg ready,         // Ready for new transaction
    output reg ack_error,     // Acknowledge error flag
    inout wire sda,           // I2C data line
    output reg scl            // I2C clock line
);

    // I2C clock divider for 100 kHz SCL
    localparam DIVIDER = 500; // 100MHz / (2 * 100kHz) = 500
    reg [9:0] clk_counter;
    
    // State machine states
    localparam IDLE = 4'd0;
    localparam START = 4'd1;
    localparam ADDRESS = 4'd2;
    localparam READ_ACK = 4'd3;
    localparam WRITE_DATA = 4'd4;
    localparam READ_DATA = 4'd5;
    localparam WRITE_ACK = 4'd6;
    localparam STOP = 4'd7;
    
    reg [3:0] state;
    reg [3:0] bit_counter;
    reg [7:0] shift_reg;
    reg sda_out;
    reg sda_enable;
    
    // Tri-state control for SDA
    assign sda = sda_enable ? sda_out : 1'bz;
    
    // Clock generation for SCL
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            clk_counter <= 0;
            scl <= 1'b1;
        end else if (state != IDLE) begin
            if (clk_counter == DIVIDER - 1) begin
                clk_counter <= 0;
                scl <= ~scl;
            end else begin
                clk_counter <= clk_counter + 1;
            end
        end else begin
            scl <= 1'b1;
            clk_counter <= 0;
        end
    end
    
    // Main state machine
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            ready <= 1'b1;
            sda_out <= 1'b1;
            sda_enable <= 1'b0;
            ack_error <= 1'b0;
            bit_counter <= 0;
        end else begin
            case (state)
                IDLE: begin
                    ready <= 1'b1;
                    sda_enable <= 1'b0;
                    if (enable) begin
                        ready <= 1'b0;
                        state <= START;
                        shift_reg <= {addr, rw};
                    end
                end
                
                START: begin
                    // Generate START condition
                    sda_enable <= 1'b1;
                    sda_out <= 1'b0;
                    if (clk_counter == DIVIDER/2) begin
                        state <= ADDRESS;
                        bit_counter <= 7;
                    end
                end
                
                ADDRESS: begin
                    // Send address + R/W bit
                    sda_out <= shift_reg[bit_counter];
                    if (clk_counter == DIVIDER - 1) begin
                        if (bit_counter == 0) begin
                            state <= READ_ACK;
                            sda_enable <= 1'b0; // Release SDA for ACK
                        end else begin
                            bit_counter <= bit_counter - 1;
                        end
                    end
                end
                
                READ_ACK: begin
                    // Read acknowledgment bit
                    if (clk_counter == DIVIDER/2 && scl) begin
                        if (sda == 1'b0) begin
                            ack_error <= 1'b0;
                            if (rw) begin
                                state <= READ_DATA;
                                bit_counter <= 7;
                            end else begin
                                state <= WRITE_DATA;
                                bit_counter <= 7;
                                shift_reg <= data_in;
                            end
                        end else begin
                            ack_error <= 1'b1;
                            state <= STOP;
                        end
                    end
                end
                
                WRITE_DATA: begin
                    // Send data byte
                    sda_enable <= 1'b1;
                    sda_out <= shift_reg[bit_counter];
                    if (clk_counter == DIVIDER - 1) begin
                        if (bit_counter == 0) begin
                            state <= READ_ACK;
                            sda_enable <= 1'b0;
                        end else begin
                            bit_counter <= bit_counter - 1;
                        end
                    end
                end
                
                READ_DATA: begin
                    // Receive data byte
                    sda_enable <= 1'b0;
                    if (clk_counter == DIVIDER/2 && scl) begin
                        shift_reg[bit_counter] <= sda;
                        if (bit_counter == 0) begin
                            data_out <= shift_reg;
                            state <= WRITE_ACK;
                        end else begin
                            bit_counter <= bit_counter - 1;
                        end
                    end
                end
                
                WRITE_ACK: begin
                    // Send ACK/NACK
                    sda_enable <= 1'b1;
                    sda_out <= 1'b1; // NACK (end of read)
                    if (clk_counter == DIVIDER - 1) begin
                        state <= STOP;
                    end
                end
                
                STOP: begin
                    // Generate STOP condition
                    sda_enable <= 1'b1;
                    sda_out <= 1'b0;
                    if (clk_counter == DIVIDER/2) begin
                        sda_out <= 1'b1;
                    end
                    if (clk_counter == DIVIDER - 1) begin
                        state <= IDLE;
                    end
                end
                
                default: state <= IDLE;
            endcase
        end
    end
    
endmodule
[aca4][H3] Temperature Data Format
[ad37][ULI] SDA (Serial Data): Bidirectional data line
[ad6a][PRE] ## Clock signal
set_property -dict { PACKAGE_PIN E3 IOSTANDARD LVCMOS33 } [get_ports { CLK100MHZ }];
create_clock -add -name sys_clk_pin -period 10.00 -waveform {0 5} [get_ports {CLK100MHZ}];

## Reset button
set_property -dict { PACKAGE_PIN C12 IOSTANDARD LVCMOS33 } [get_ports { reset }];

## Temperature Sensor I2C
set_property -dict { PACKAGE_PIN C14 IOSTANDARD LVCMOS33 } [get_ports { SCL }];
set_property -dict { PACKAGE_PIN C15 IOSTANDARD LVCMOS33 } [get_ports { SDA }];

## Seven segment display
set_property -dict { PACKAGE_PIN T10 IOSTANDARD LVCMOS33 } [get_ports { seg[0] }];
set_property -dict { PACKAGE_PIN R10 IOSTANDARD LVCMOS33 } [get_ports { seg[1] }];
set_property -dict { PACKAGE_PIN K16 IOSTANDARD LVCMOS33 } [get_ports { seg[2] }];
set_property -dict { PACKAGE_PIN K13 IOSTANDARD LVCMOS33 } [get_ports { seg[3] }];
set_property -dict { PACKAGE_PIN P15 IOSTANDARD LVCMOS33 } [get_ports { seg[4] }];
set_property -dict { PACKAGE_PIN T11 IOSTANDARD LVCMOS33 } [get_ports { seg[5] }];
set_property -dict { PACKAGE_PIN L18 IOSTANDARD LVCMOS33 } [get_ports { seg[6] }];
set_property -dict { PACKAGE_PIN H15 IOSTANDARD LVCMOS33 } [get_ports { DP }];

## Anodes
set_property -dict { PACKAGE_PIN J17 IOSTANDARD LVCMOS33 } [get_ports { AN[0] }];
set_property -dict { PACKAGE_PIN J18 IOSTANDARD LVCMOS33 } [get_ports { AN[1] }];
set_property -dict { PACKAGE_PIN T9 IOSTANDARD LVCMOS33 } [get_ports { AN[2] }];
set_property -dict { PACKAGE_PIN J14 IOSTANDARD LVCMOS33 } [get_ports { AN[3] }];
set_property -dict { PACKAGE_PIN P14 IOSTANDARD LVCMOS33 } [get_ports { AN[4] }];
set_property -dict { PACKAGE_PIN T14 IOSTANDARD LVCMOS33 } [get_ports { AN[5] }];
set_property -dict { PACKAGE_PIN K2 IOSTANDARD LVCMOS33 } [get_ports { AN[6] }];
set_property -dict { PACKAGE_PIN U13 IOSTANDARD LVCMOS33 } [get_ports { AN[7] }];

## LEDs for debugging
set_property -dict { PACKAGE_PIN H17 IOSTANDARD LVCMOS33 } [get_ports { LED[0] }];
set_property -dict { PACKAGE_PIN K15 IOSTANDARD LVCMOS33 } [get_ports { LED[1] }];
set_property -dict { PACKAGE_PIN J13 IOSTANDARD LVCMOS33 } [get_ports { LED[2] }];
set_property -dict { PACKAGE_PIN N14 IOSTANDARD LVCMOS33 } [get_ports { LED[3] }];
set_property -dict { PACKAGE_PIN R18 IOSTANDARD LVCMOS33 } [get_ports { LED[4] }];
set_property -dict { PACKAGE_PIN V17 IOSTANDARD LVCMOS33 } [get_ports { LED[5] }];
set_property -dict { PACKAGE_PIN U17 IOSTANDARD LVCMOS33 } [get_ports { LED[6] }];
set_property -dict { PACKAGE_PIN U16 IOSTANDARD LVCMOS33 } [get_ports { LED[7] }];
set_property -dict { PACKAGE_PIN V16 IOSTANDARD LVCMOS33 } [get_ports { LED[8] }];
set_property -dict { PACKAGE_PIN T15 IOSTANDARD LVCMOS33 } [get_ports { LED[9] }];
set_property -dict { PACKAGE_PIN U14 IOSTANDARD LVCMOS33 } [get_ports { LED[10] }];
set_property -dict { PACKAGE_PIN T16 IOSTANDARD LVCMOS33 } [get_ports { LED[11] }];
set_property -dict { PACKAGE_PIN V15 IOSTANDARD LVCMOS33 } [get_ports { LED[12] }];
set_property -dict { PACKAGE_PIN V14 IOSTANDARD LVCMOS33 } [get_ports { LED[13] }];
set_property -dict { PACKAGE_PIN V12 IOSTANDARD LVCMOS33 } [get_ports { LED[14] }];
set_property -dict { PACKAGE_PIN V11 IOSTANDARD LVCMOS33 } [get_ports { LED[15] }];
[ad7c][H3] Mastering I²C on FPGA: Reading Temperature Data from the ADT7420 in Verilog
[ae07][PRE] module temp_reader (
    input wire clk,
    input wire reset,
    output reg [15:0] temperature_raw,
    output reg [7:0] temp_celsius,
    output reg [3:0] temp_fraction,
    output reg data_valid,
    inout wire sda,
    output wire scl
);

    // ADT7420 slave address
    localparam SENSOR_ADDR = 7'h4B;
    localparam TEMP_REG = 8'h00;
    
    // State machine for reading temperature
    localparam IDLE = 3'd0;
    localparam WRITE_REG_ADDR = 3'd1;
    localparam RESTART = 3'd2;
    localparam READ_MSB = 3'd3;
    localparam READ_LSB = 3'd4;
    localparam CONVERT = 3'd5;
    localparam WAIT = 3'd6;
    
    reg [2:0] state;
    reg [23:0] wait_counter;
    
    // I2C master signals
    reg i2c_enable;
    reg i2c_rw;
    reg [7:0] i2c_data_in;
    wire [7:0] i2c_data_out;
    wire i2c_ready;
    wire i2c_ack_error;
    
    reg [7:0] temp_msb, temp_lsb;
    
    // Instantiate I2C master
    i2c_master i2c (
        .clk(clk),
        .reset(reset),
        .enable(i2c_enable),
        .rw(i2c_rw),
        .addr(SENSOR_ADDR),
        .data_in(i2c_data_in),
        .data_out(i2c_data_out),
        .ready(i2c_ready),
        .ack_error(i2c_ack_error),
        .sda(sda),
        .scl(scl)
    );
    
    // Main state machine
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            i2c_enable <= 1'b0;
            data_valid <= 1'b0;
            wait_counter <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (wait_counter == 24'd10_000_000) begin // Wait 100ms
                        wait_counter <= 0;
                        state <= WRITE_REG_ADDR;
                    end else begin
                        wait_counter <= wait_counter + 1;
                    end
                end
                
                WRITE_REG_ADDR: begin
                    if (i2c_ready && !i2c_enable) begin
                        // Write temperature register address
                        i2c_rw <= 1'b0; // Write
                        i2c_data_in <= TEMP_REG;
                        i2c_enable <= 1'b1;
                    end else if (i2c_enable) begin
                        i2c_enable <= 1'b0;
                        if (!i2c_ack_error) begin
                            state <= READ_MSB;
                        end else begin
                            state <= IDLE; // Retry on error
                        end
                    end
                end
                
                READ_MSB: begin
                    if (i2c_ready && !i2c_enable) begin
                        // Read MSB of temperature
                        i2c_rw <= 1'b1; // Read
                        i2c_enable <= 1'b1;
                    end else if (i2c_enable) begin
                        i2c_enable <= 1'b0;
                        if (!i2c_ack_error) begin
                            temp_msb <= i2c_data_out;
                            state <= READ_LSB;
                        end else begin
                            state <= IDLE;
                        end
                    end
                end
                
                READ_LSB: begin
                    if (i2c_ready && !i2c_enable) begin
                        // Read LSB of temperature
                        i2c_rw <= 1'b1; // Read
                        i2c_enable <= 1'b1;
                    end else if (i2c_enable) begin
                        i2c_enable <= 1'b0;
                        if (!i2c_ack_error) begin
                            temp_lsb <= i2c_data_out;
                            state <= CONVERT;
                        end else begin
                            state <= IDLE;
                        end
                    end
                end
                
                CONVERT: begin
                    // Combine MSB and LSB
                    temperature_raw <= {temp_msb, temp_lsb};
                    
                    // Convert to Celsius (13-bit mode)
                    // Temperature = Raw / 128
                    // For display: integer and fractional parts
                    temp_celsius <= temperature_raw[15:7]; // Integer part
                    temp_fraction <= (temperature_raw[6:3] * 625) / 1000; // Fractional
                    
                    data_valid <= 1'b1;
                    state <= WAIT;
                end
                
                WAIT: begin
                    data_valid <= 1'b0;
                    state <= IDLE; // Return to idle for next reading
                end
                
                default: state <= IDLE;
            endcase
        end
    end
    
endmodule
[af58][ULI] Open-drain outputs requiring pull-up resistors
[afea][H3] 1. I²C Master Controller
[b0c7][OLI] Power on the board
[b1f8][P] Finally, let’s display our temperature readings:
[b397][ULI] Ensure pull-up resistors are enabled (usually internal to FPGA)
[b84d][H3] Seven-Segment Display Controller
[b8a4][OLI] Create the source files for all modules
[b8e5][H3] I²C Master Module
[bd2e][PRE] Master → Slave Address (0x4B) + Write (0)
Master → Register Address
Master → RESTART
Master → Slave Address (0x4B) + Read (1)
Master ← Data Byte(s)
Master → STOP
[bf3e][IMG] Nexys A7 FPGA board displaying real-time temperature data from the onboard ADT7420 sensor
[c016][PRE] module seven_seg_display (
    input wire clk,
    input wire reset,
    input wire [7:0] temp_celsius,
    input wire [3:0] temp_fraction,
    output reg [7:0] an,      // Anode control
    output reg [6:0] seg,     // Segment control (CA-CG)
    output reg dp             // Decimal point
);

    // Display refresh rate (1 kHz per digit)
    localparam REFRESH_COUNT = 100_000; // For 100MHz clock
    reg [16:0] refresh_counter;
    reg [2:0] digit_select;
    
    // BCD digits for display
    reg [3:0] digit [0:7];
    
    // Convert temperature to BCD
    always @(*) begin
        // Display format: "  25.6 C  " (showing temp with 1 decimal)
        digit[7] = 4'd10; // Blank
        digit[6] = 4'd10; // Blank
        digit[5] = temp_celsius / 10;    // Tens of degrees
        digit[4] = temp_celsius % 10;    // Ones of degrees
        digit[3] = temp_fraction;         // Decimal fraction
        digit[2] = 4'd12;                 // 'C' for Celsius
        digit[1] = 4'd10;                 // Blank
        digit[0] = 4'd10;                 // Blank
    end
    
    // Refresh counter for multiplexing
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            refresh_counter <= 0;
            digit_select <= 0;
        end else begin
            if (refresh_counter == REFRESH_COUNT - 1) begin
                refresh_counter <= 0;
                digit_select <= digit_select + 1;
            end else begin
                refresh_counter <= refresh_counter + 1;
            end
        end
    end
    
    // Anode control (active low)
    always @(*) begin
        an = 8'b1111_1111;
        an[digit_select] = 1'b0;
    end
    
    // Decimal point control
    always @(*) begin
        dp = (digit_select == 3'd4) ? 1'b0 : 1'b1; // DP after ones digit
    end
    
    // Seven-segment decoder
    always @(*) begin
        case (digit[digit_select])
            4'd0: seg = 7'b1000000; // 0
            4'd1: seg = 7'b1111001; // 1
            4'd2: seg = 7'b0100100; // 2
            4'd3: seg = 7'b0110000; // 3
            4'd4: seg = 7'b0011001; // 4
            4'd5: seg = 7'b0010010; // 5
            4'd6: seg = 7'b0000010; // 6
            4'd7: seg = 7'b1111000; // 7
            4'd8: seg = 7'b0000000; // 8
            4'd9: seg = 7'b0010000; // 9
            4'd10: seg = 7'b1111111; // Blank
            4'd12: seg = 7'b1000110; // C
            default: seg = 7'b1111111;
        endcase
    end
    
endmodule
[c01d][OLI] Observe temperature display on seven-segment displays
[c18f][PRE] 1. START condition (SDA falls while SCL is high)
2. Send slave address (7 bits) + Write bit (0)
3. Send register address to read from
4. RESTART condition
5. Send slave address + Read bit (1)
6. Receive data byte(s)
7. STOP condition (SDA rises while SCL is high)
[c512][P] Now let’s create the controller that uses the I²C master to read temperature:
[c622][ULI] Reads temperature register (0x00:0x01)
[c63e][P] Insert ILA cores to monitor signals:
[c6ae][P] In this tutorial, I’ll walk you through my journey of interfacing an ADT7420 temperature sensor with a Nexys A7 FPGA board using Verilog HDL. We’ll explore I²C communication, understand register-level interactions, and display live temperature readings on seven-segment displays. This project bridges the gap between theoretical digital design and real-world sensor integration.
[cc81][OLI] Run synthesis
[ccec][H3] Common Issues and Solutions
[cd26][OLI] Run implementation
[cd96][ULI] Optionally controls LEDs for status/debugging
[d0c9][OLI] Generate bitstream
[d29f][P] A typical I²C read transaction looks like this:
[d41c][ULI] Solutions:
[d7fc][H3] Step 1: Project Setup
[dbbb][H3] 2. Temperature Reader Module
[dc0f][H3] Temperature Reader Module
[dd81][P] I²C uses just two lines:
[ddaf][P] Conversion Formula:
[de1d][ULI] Interface: I²C (Inter-Integrated Circuit)
[dfff][OLI] Select XC7A100T-1CSG324 (Nexys A7) as target device
[e670][P] Writing to Registers:
[e8d9][ULI] Verify conversion formula (divide by 128 for 13-bit mode)
[e9a1][PRE] Temperature (°C) = (Raw_Value / 128) if 13-bit mode
Temperature (°C) = (Raw_Value / 16) if 16-bit mode
[e9b8][H3] 3. Display Controller
[e9d4][P] 2. Incorrect Temperature Readings
[ec10][OLI] Connect Nexys A7 board via USB
[ec5f][PRE] module temp_sensor_top (
    input wire CLK100MHZ,
    input wire reset,
    inout wire SDA,
    output wire SCL,
    output wire [7:0] AN,
    output wire [6:0] seg,
    output wire DP,
    output wire [15:0] LED
);

    wire [15:0] temperature_raw;
    wire [7:0] temp_celsius;
    wire [3:0] temp_fraction;
    wire data_valid;
    
    // Instantiate temperature reader
    temp_reader reader (
        .clk(CLK100MHZ),
        .reset(reset),
        .temperature_raw(temperature_raw),
        .temp_celsius(temp_celsius),
        .temp_fraction(temp_fraction),
        .data_valid(data_valid),
        .sda(SDA),
        .scl(SCL)
    );
    
    // Instantiate display controller
    seven_seg_display display (
        .clk(CLK100MHZ),
        .reset(reset),
        .temp_celsius(temp_celsius),
        .temp_fraction(temp_fraction),
        .an(AN),
        .seg(seg),
        .dp(DP)
    );
    
    // Display raw temperature on LEDs for debugging
    assign LED = temperature_raw;
    
endmodule
[f1f0][P] High-level control logic:
[f2da][P] Building this temperature sensor interface has been an incredible journey from understanding I²C protocol specifications to seeing real-time temperature readings on hardware. The project demonstrates how FPGAs bridge the gap between low-level hardware communication and user-friendly displays.
[f43d][PRE] Master → Slave Address (0x4B) + Write (0)
Master → Register Address
Master → Data Byte(s)
Master → STOP
[f51f][P] Handles low-level I²C protocol:
[f6cb][H3] I²C Protocol: The Communication Backbone
[f748][OLI] Add all Verilog source files
[f8ce][ULI] Provides industry-standard I²C interface
[f9f7][P] The Nexys A7 board comes equipped with an Analog Devices ADT7420 temperature sensor via highly accurate digital temperature sensor with impressive specifications:
[fa5c][ULI] Accuracy: Better than 0.25°C typical
[fb40][P] Bringing it all together:
[fe6d][H3] I²C Transaction Flow
[feb8][P] Ever wondered how your smart thermostat communicates with temperature sensors? Or how embedded systems read environmental data in real-time? The answer often lies in I²C communication — a simple yet powerful protocol for device-to-device communication.
[ff6d][H3] Top-Level Module
