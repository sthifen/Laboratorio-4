# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a RISC-V RV32I processor system-on-chip (SoC) design project for the Nexys 4 DDR FPGA board (Artix-7 xc7a100tcsg324-1). The project implements a custom processor with a PCPI (cooperative processor interface) architecture, integrating peripherals for timer control, temperature sensing, 7-segment display, and LED output.

**Active Vivado Project:** `lab4_pcpi/lab4_pcpi.xpr`

## Build Commands

### Open Vivado Project
```bash
vivado lab4_pcpi/lab4_pcpi.xpr &
```

### Automated Synthesis/Implementation
```bash
vivado -mode batch -source scripts/vivado/run_full_flow.tcl
```

### ROM/HEX Validation
```bash
vivado -mode batch -source scripts/vivado/check_rom.tcl
```

## Simulation

### Vivado Simulator (xsim)
```bash
xvlog -sv rtl/*.sv sim/tb_unified_pcpi.sv
xelab tb_unified_pcpi -debug typical
xsim tb_unified_pcpi -R --testplusarg firmware=firmware/firmware.hex
```

Add `+vcd` plusarg for waveform debugging.

### Icarus Verilog (smoke tests)
```bash
iverilog -g2012 -o build/tb_unified sim/tb_unified_pcpi.sv rtl/*.sv
vvp build/tb_unified +firmware=firmware/firmware.hex
```

**Primary testbench:** `sim/tb_unified_pcpi.sv` (372 lines) - loads firmware, simulates ROM/RAM, monitors LED writes, validates instruction execution.

## Firmware Assembly

### Python Assembler (Standalone)
```bash
python firmware/assemble_firmware.py
```
- Auto-generates `firmware/firmware.hex` and `firmware/firmware.coe`
- Auto-updates `lab4_pcpi/lab4_pcpi.srcs/sources_1/imports/lab4s/firmware.hex`
- No external RISC-V toolchain required
- Supports: lui, addi, andi, ori, slli, srai, lw, sw, beq, bne, blt, bge, jal, jalr, or

### External RISC-V Toolchain (Alternative)
```bash
riscv32-unknown-elf-as firmware/firmware_pcpi.asm -o firmware.o
riscv32-unknown-elf-objcopy -O verilog firmware.o firmware/firmware.hex
```

**Always rebuild firmware.hex after editing firmware_pcpi.asm before running simulations.**

## High-Level Architecture

### PCPI-Based Execution Model

The core architecture separates instruction fetch/decode (in `rv32i_core.sv`) from execution (in the PCPI modules). The PCPI interface acts as a cooperative coprocessor:

1. **rv32i_core.sv** - FSM-based processor core
   - States: RESET → FETCH → FETCH_WAIT → DECODE → MEM_ACCESS → WRITEBACK
   - Fetches instructions from ROM (0x0000-0x0FFF)
   - Decodes opcodes and presents instructions to PCPI
   - Manages 32×32-bit register file (x0 hardwired to 0)
   - Handles program counter and control flow

2. **unified_pcpi_module.sv** (310 lines) - Main execution unit
   - **Integration point** combining Steven's ALU baseline + Diego's extensions
   - Decodes and executes R-type (add, sub, and, or, xor), I-type (addi), J-type (jal)
   - Orchestrates load/store and shift sub-units
   - Handles PC-relative jumps (JAL)
   - Multiplexes results from ALU/load/store/shift paths back to core

3. **Specialized Execution Units:**
   - `load_store_unit.sv` (140 lines) - Executes lw/sw, manages memory interface
   - `shifter_unit.sv` (68 lines) - Arithmetic/logical shifts (sll/slli, srl/srli, sra/srai)
   - `decoder_load_store_shift.sv` (134 lines) - Decodes load/store/shift instructions

### Memory Map

From official lab spec (`docs/Proyectos_laboratorio4_EL3313_proyecto.pdf`):

| Address | Peripheral | Access | Notes |
|---------|-----------|--------|-------|
| 0x0000-0x0FFF | ROM (instruction) | Read-only | 512 words, initialized via firmware.coe |
| 0x1000-0x1FFF | RAM (data) | Read-write | 256 words |
| 0x2000 | Switches/Buttons | Read | {10'b0, TMP_CT, TMP_INT, btnU, btnD, btnL, btnR, sw[15:0]} |
| 0x2004 | LEDs | Write | 16-bit output |
| 0x2008 | 7-segment display | Write | 32-bit (8 nibbles, AN0=LSB nibble) |
| 0x2018 | Timer control | Read/Write | bit0=start, bit1=clr_done |
| 0x201C | Timer period | Read/Write | Ticks @ 10MHz |
| 0x2030 | Temp sensor control | Read/Write | bit0=start, bit1=clr_ready |
| 0x2034 | Temp sensor data | Read | 16-bit signed, tenths of °C |

### Clock Architecture

- **External clock:** 100 MHz (Nexys 4 DDR E3 pin)
- **System clock:** 10 MHz (generated by `clk_i` PLL IP)
- All processor logic, peripherals, and memory run on 10 MHz clock
- No additional clock domains unless explicitly generated within IP blocks

### Top-Level Integration

**File:** `lab4_pcpi/lab4_pcpi.srcs/sources_1/new/top_pcpi_led_fpga.sv` (298 lines)

Instantiates:
- Clock PLL (`clk_i` IP: 100MHz → 10MHz)
- `rv32i_core` (processor FSM)
- ROM and RAM IP cores (initialized via firmware.coe)
- `timer_peripheral.sv` (programmable countdown timer)
- `seven_seg_driver.sv` (8-digit multiplexed hexadecimal display)
- `temp_sensor_xadc.sv` (on-chip temperature sensor via XADC)
- `io_sync_debounce.sv` (button/switch synchronizer and debouncer)

Exports I/O:
- 16 LEDs (LD0-LD15)
- 8-digit 7-segment displays (cathodes CA-CG + DP, anodes AN0-AN7)
- 5 buttons (BTNL, BTNR, BTNU, BTND, BTNC=reset)
- 16 switches (SW0-SW15)
- I2C and XADC signals (reserved for external temperature sensor)

### Temperature Sensor Implementation

**File:** `temp_sensor_xadc.sv` (80+ lines)

Uses Nexys 4 DDR on-chip XADC for temperature measurement:
- Converts 12-bit ADC reading to °C × 10 (tenths of degree)
- Formula: `T_tenths = (raw * 5040 >> 12) - 2731`
- Memory-mapped: control at 0x2030, data at 0x2034
- Control bit0=start conversion, bit1=clear ready flag
- Data returns 16-bit signed temperature in tenths of °C

External ADT7420 I2C sensor interface not yet implemented.

## Directory Structure

- **`rtl/`** - Active RTL modules (PCPI datapath: unified_pcpi_module, load_store_unit, shifter_unit, decoder)
- **`sim/`** - Testbenches (tb_unified_pcpi.sv is the authoritative regression test)
- **`firmware/`** - Assembly sources (.asm), hex images (.hex), Python assembler
- **`lab4_pcpi/`** - Deployable Vivado project (synthesis-ready)
- **`docs/`** - Lab specifications, datasheets, sensor documentation
- **`scripts/vivado/`** - Tcl automation scripts (run_full_flow.tcl, check_rom.tcl)
- **`legacy/`** - Reference implementations (steven_reference/, diego_reference/, lab4_snapshot/)
- **`logs/`** - Build and synthesis logs

## Coding Style

- **Language:** SystemVerilog (IEEE 1800-2017)
- **Naming:** `lower_snake_case` for all identifiers
- **Indentation:** 4 spaces
- **Types:** Prefer `logic` over `reg`/`wire`
- **FSM:** Use `enum` with explicit state names
- **Sequential logic:** `always_ff @(posedge clk or negedge rst_n)`
- **Combinational logic:** `always_comb` or `assign`
- **Debug messages:** Bilingual (mostly Spanish) using `$display`, gated when appropriate
- **File naming:** Describe role (`tb_*` for testbenches, `*_unit` for execution units)

## Testing Guidelines

1. **Primary regression:** Always run `tb_unified_pcpi.sv` with matching firmware
2. **Waveform debugging:** Add `+vcd` plusarg to generate waveforms
3. **Legacy unit tests:** Use `legacy/steven_reference/tb_alu_steven.sv` and `legacy/diego_reference/tb_diego_complete.sv` for focused testing
4. **New testbenches:** Name as `tb_<module>_<scenario>.sv`
5. **Coverage targets:** Validate all opcodes, LED peripheral writes, memory operations
6. **PR requirements:** Include console excerpts showing load, store, shift, JAL execution paths

## Known Gaps (from AGENTS.md)

1. **CPU completeness** - Only PCPI coprocessor exists; needs full RV32I core or decision to integrate with PicoRV32
2. **Missing instructions** - slt, sltu, and full branch coverage (beq, bne, blt, bge)
3. **Real memory interconnect** - Testbench uses internal memories; needs shared bus arbiter for RAM and peripherals
4. **Firmware completeness** - Current demo only tests ALU; needs full sensor reading, decimal conversion, display control
5. **Hardware verification** - Top-level design created but not fully tested on physical FPGA board

## Peripheral Implementation Details

### Timer Peripheral
- **Control register (0x2018):**
  - Write: bit0=start countdown, bit1=clear done flag
  - Read: bit0=running status, bit1=done flag
- **Period register (0x201C):** Number of 10MHz ticks to count
- Counts down from period value, sets done flag on completion

### Seven-Segment Display Driver
- **Data register (0x2008):** 32-bit value displayed as 8 hex nibbles
- Multiplexed display: cycles through anodes AN0-AN7
- AN0 displays LSB nibble, AN7 displays MSB nibble
- Decimal point enabled on digit 1 (units place)

### IO Synchronization
- All external inputs (buttons, switches) pass through `io_sync_debounce.sv`
- Provides metastability protection and debouncing
- Parameterized width and counter depth

## Pin Constraints

**File:** `lab4_pcpi/lab4_pcpi.srcs/constrs_1/new/Const.xdc`

- All I/O uses LVCMOS33 standard
- Clock input: E3 (100 MHz)
- Reset button: E16 (BTNC)
- Edit Const.xdc to maintain synchronization with Nexys 4 DDR board

## Commit Conventions

- **Language:** Spanish subjects preferred (follow existing pattern)
- **Subject line:** Under 60 characters, descriptive
- **Body:** Describe firmware/HDL changes, verification steps, Vivado warnings
- **PR requirements:** Summarize scope, list verification commands, attach waveforms/screenshots for hardware behavior changes
- **Never commit:** Generated folders (*.cache/, *.hw/, *.sim/, *.gen/, *.bit, *.dcp)

## Critical Files Reference

- **Top-level FPGA:** `lab4_pcpi/lab4_pcpi.srcs/sources_1/new/top_pcpi_led_fpga.sv`
- **Processor core:** `lab4_pcpi/lab4_pcpi.srcs/sources_1/new/rv32i_core.sv`
- **PCPI integration:** `rtl/unified_pcpi_module.sv`
- **Main testbench:** `sim/tb_unified_pcpi.sv`
- **Firmware assembler:** `firmware/assemble_firmware.py`
- **Lab demo firmware:** `firmware/firmware_pcpi.asm`
- **Pin constraints:** `lab4_pcpi/lab4_pcpi.srcs/constrs_1/new/Const.xdc`
- **Project guidelines:** `AGENTS.md` (comprehensive bilingual reference)
- **Lab specification:** `docs/Proyectos_laboratorio4_EL3313_proyecto.pdf`
